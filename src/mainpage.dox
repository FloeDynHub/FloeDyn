/*!
 *
 * \mainpage Code C++ de simulation de floes
 *
 * \tableofcontents
 *
 ********************************************************************************************************************************************
 * \section dev_todo À faire dans le code.
 **********************************************
 *
 * - Tout traduire en Anglais !!!
 * - Générer une page de d'aide à l'installation et au lancement du code
 * - Générateur de configurations initiales de floes
 * - Compléter la documentation
 * - Créer des tests références pour vérifier que tout fonctionne bien
 * - Corriger bugs pour passer sur version ulterieure de <b> BOOST </b>
 *
 *****************
 * \subsection dev_optim Optimisation
 *****************
 * \subsubsection dev_solver Solveur LCP
 * - voir la méthode de réduction de dimension de Lloyd 2005 (O(n^3) -> O(n))
 * - rendre plus propre la résolution des LCP par le développements des outils de base nécessaires : recherche de la variable bloquante, pivot, etc ...
 * - ensuite, permettre de modifier le comportement de ces outils, pour par exemple utiliser l'algo d'expansion du LCP de Lloyd 2005.
 * - voir Acary 2011 : A formulation of the linear discrete Coulomb friction problem via convex optimization. The novelty of their approach is to capture and treat directly the friction model as a parametric quadratic optimization problem with second-order cone constraints coupled with a fixed point equation.
 *
 *****************
 * \subsubsection dev_multithread Parallélisation
 *****************
 * - on peut facilement paralléliser la détection de contact,
 * - de même pour la résolution des contacts : à une étape donnée (groupes de contacts actifs), tous les LCPs peuvent se résoudre indépendamment les uns des autres ;
 * - à plus grande échelle, il faudrait pouvoir gérer l'ensemble des floes par groupes. On peut déjà avoir un détecteur de collision indépendant par groupe, il faut alors un autre détecteur sur les groupes eux-mêmes. Il faut également pouvoir détecter les "influences" entre groupes.
 * - Voir Drumwright 2010 (chapitre précédent), pour une optimisation sur GPU.
 * - Voir Mazhar 2015 pour une gestion des contacts avec méthodes facilement parallèlisable (accelerated projected gradient descent (APGD) method relies on an approach by Nesterov in which a quadratic optimization problem with conic constraints is solved at each simulation time step to recover the normal and friction forces present in the system).
 *
 ********************************************************************************************************************************************
 * \section Installation
 **********************************************
 *
 *****************
 * \subsection Prerequisite
 *****************
 * If you clone the GIT repository, you need at least the following to build the executable:
 * - Boost (version 1.67) (not earlier 1.64, <i> UBlas -> QVM </i>).
 * 		+ Use for geometry, graphs, linear algebra, etc.
 * - Matio (version 1.5.12) (not earlier 1.5.12, bug still unfixed).
 *		+ Use for importing/exporting Matlab format files.
 * - Eigen (version no matter, works with 3.3.4)
 * 		+ Use for linear algebra for linear complementarity problem.
 * - CGAL (version no matter)
 * 		+ Use for construction of mesh during the generation of floe assemblies.
 * - HDF5 (version 1.10, addind <a href="https://support.hdfgroup.org/products/java/release/download.html">HDFView </a> for visualing files .h5) (not earlier 1.10, minor modification see commit history).
 * 		+ Use for outputs.
 * - ffmpeg (version no matter)
 *		+ Use for generation of videos.
 * - python (version 3.6.5) (addind h5py, numpy and matplotlib) (not later 3.6.5, bug still unfixed, see issue).
 * 		+ Use for visualisation and generation of videos from outputs.
 * - doxygen (version no matter)
 * 		+ Use for generating documentation.
 * - graphviz (version no matter)
 * 		+ Use for generating graphics during the documentation generation.
 *
 * Every library could be installed with home brew. However you should be careful about: 
 * - when one install boost_1_67 with brew, one should check the folders <i> /usr/local/lib/ </i> and <i> /usr/local/include/ </i> contain the boost libraries and include (or link). It is required to compile.
 * Otherwise, one should install boost_1_67 without brew (see: <a href="http://www.boost.org/doc/libs/1_65_1/more/getting_started/unix-variants.html">the boost user manual for unix-variants</a>). 
 * - when one install CGAL with brew, CGAL needing boost, it may be that brew install the lastest version of boost. In this case, please install CGAL without brew 
 * (see: <a href="https://doc.cgal.org/latest/Manual/installation.html">CGAL user manual </a>).
 *
 *****************
 * \subsection get_start Getting Started
 *****************
 * Once libraries have been installed, please check with the command:
 *
 * \code
 * $ cd /path/to/FloeCpp
 * $ ./waf configure
 * \endcode
 *
 * The default path is <i> /usr </i>. To specify the path (e.g.: <i> /home/user_name/ </i>):
 * \code
 * $ ./waf configure --default-search-path=/home/user_name
 * \endcode 
 *
 * If one are using <b> nix </b> solftware:
 * The default path is <i> /usr </i>. To specify the path (e.g.: <i> /home/user_name/ </i>):
 * \code
 * $ ./waf configure --default-search-path=/home/user_name/.nix-profile
 * \endcode 
 *
 * You should obtain something like this:
 * \image html waf_config.png width=800
 *
 *****************
 * \subsection Compilation
 *****************
 * \code
 * $ ./waf --target FLOE
 * \endcode
 *
 * or 
 * \code
 * $ ./waf --target FLOE_PBC
 * \endcode
 *
 * or, all <i> .cpp </i> files contained in <i> product </i> folder. The executable are in the <i> build </i> folder.
 *
 *****************
 * \subsection first_run First Running
 *****************
 * Run:
 * \code
 * $ ./build/FLOE -h
 * \endcode
 * allow to know which options are availables
 *
 * Before running any simulations, please build floe configurations:
 * \code
 * $ ./build/FLOE -i generator -n 1000 -c 0.6 -t 0
 * \endcode
 * generation of 1000 floes with a concentration equal to 60 percent. At the end, the simulation, which the last is <i> t=0 </i>, starts.
 * One should keep the default size (250 m) during the generation phase since the external forces (specially winds) are suitable to ensure
 * floes penetrate in the target zone in order to reach the required ice concentration as soon as possible. (the speed in convergent_outside_window_field should be constant equal to 1)
 * The floe size may be adjusted later on with the command: 
 * \code
 * $ ./build/FLOE_RESIZE_INPUT io/inputs/in_100f_20p_5kslF.h5 10000
 * \endcode 
 * 10000 is the size (in meters) of the target zone. The ice floes are resize to fit with the new target zone. 
 *
 * First example:
 * \code
 * $ ./build/FLOE -i io/inputs/in_700f_60p_#1.h5 -t 10000
 * \endcode
 * running the floe configuration called <i> in_700f_60p_#1.h5 </i> (for 700 floes with a ice concentration equal to 60 percent) during 10000 secondes.
 * 
 * The output files (in .h5) are in the <i> io/outputs </i> folder. To generate a video, please type:
 * \code
 * $ python3 plot anim -f io/outputs/outputs.h5
 * \endcode
 * replacing <i> outputs.h5 </i> by the name of the outputs files in the <i> io/outputs </i> folder.
 * Be careful, <i> plot </i> is a folder containing <b> python </b> files in order to create a video in <i> videos </i> folder. One have to build the <i> io/videos </i> folder before.
 * The option <i> -s n </i> is the time step (1 image for each n second, n=1 by default).
 * The option <i> -a 'xmin,xmax,ymin,ymax' </i> is the window size (e.g: ' -1200,200,-500,500', the blank is important before the minus!). 
 * 
 * Informations on the floe assemblies:
 * \code
 * $ ./build/FLOE_INPUT_INFO io/inputs/in_2000f_60p_jKtIx.h5
 * \endcode 
 *
 * To generate an image of the floe assembly:
 * \code
 * $ python3 plot img -f io/outputs/outputs.h5
 * \endcode
 *
 * To generate the documentation, please use doxygen:
 * \code
 * $ doxygen dox_file.cfg
 * \endcode
 * with <i> dox_file.cfg </i> the configuration file.
 *
 ********************************************************************************************************************************************
 * \section computing Computing
 **********************************************
 *
 *****************
 * \subsection gen Generation of more complex floe assemblies:
 *****************
 * The generator is able to handle less than 5 000 floes. An good optimum is about 2 000 floes.
 * Then to create a huge floe assembly (<i> >10 000 floes </i>), one should use the following processus:
 * - Knowing the total area of the floe assembly, split it in N*P cells (equal or not) containing about at the most 2 000 floes.
 * - Generate the part of the floe assembly associated with each cells separately (using the generator).
 * - Use the executable <i> FLOE_PATCHWORK_INPUT </i> to reproduce the whole area. Be careful the placement is random.
 * - Instead, one can use <i> FLOE_MAKE_NXP_INPUT </i>, yet this loads N * P times the same input file (i.e.: same floe assembly N*P repeated).
 * 
 *****************
 * \subsection ex First examples of run simulations:
 *****************
 * - with Periodic Boundary Conditions (PBC) with the Ocean Boundary Layer (OBL) actived:
 * \code
 * $ ./build/FLOE_PBC -i io/inputs/in_1000f_70p_l2o0h.h5 --obl 1 -t 10000
 * \endcode
 * - like a MPI simulation:
 * \code
 * $ mpirun -np 2 ./build/FLOE_MPI -i io/inputs/in_11200f_80p_UKXcR.h5 -t 500
 * \endcode
 * - from a <i> matlab </i> file:
 * \code
 * $ ./build/FLOE -i io/inputs/config_4500_square_obs.mat -t 16000
 * \endcode
 * - from a <i> outputfile.h5 </i> (to resume a previously stopped simulation at the <i> breaktime </i>):
 * \code
 * $ ./build/FLOE -i io/inputs/inputfile -r breaktime -f io/outputs/outputfile.h5 -t finaltime
 * \endcode
 *
 *****************
 * \subsection parallel Parallel Computing
 *****************
 * This is possible to run a MPI simulation:
 * \code
 * $ mpirun -np 2 ./build/FLOE_MPI -i io/inputs/floes_config.h5 -t 10000
 * \endcode
 *
 * with <i> np </i> options is the number of processor determined by: 
 * \code
 * $ python froggy.py -n 1
 * \endcode
 * where <i> n </i> is the dimension from the <i> MPI min max grid dim </i> displayed when one launch:
 * \code
 * ./build/FLOE_INPUT_INFO io/inputs/floes_config.h5
 * \endcode
 *
 ********************************************************************************************************************************************
 * \section Debug
 **********************************************
 *
 * Two tools:
 * - with <b> X-Code </b>.
 * - with <b> valgrind </b>.
 * 
 *****************
 * \subsection val with valgrind:
 *****************
 * First, please compilling without <i> --debug </i>:
 * \code 
 * $ ./waf --target FLOE
 * \endcode
 * Then, launching the simulation with the command: 
 * \code 
 * $ valgrind --leak-check=full ./build/FLOE -i io/inputs/in_700f_60p_#1.h5 -t 10000
 * \endcode
 *
 *****************
 * \subsection xcode with X-Code (or just with option --debug):
 *****************
 * First, please compilling with <i> --debug </i>:
 * \code 
 * $ ./waf --target FLOE --debug
 * \endcode
 * So, the different <i> assert() </i> function will be activated.
 *
 ********************************************************************************************************************************************
 * \section contact_detection Contact Detection
 **********************************************
 *
 *****************
 * \subsection contact_point Contact Point
 *****************
 * The contact point between the floes <i> S1 </i> and <i> S2 </i> is treated as a struct ContactPoint with the following public members:
 * - a pointer to the floe <i> S1 </i>
 * - a pointer to the floe <i> S2 </i>
 * - a frame of the contact (orthonormal and direct oriented) 
 * - the distance between <i> S1 </i> and <i> S2 </i>
 *
 *****************
 * \subsection contact_graph Contact Graph
 *****************
 * The graph of contact is treated as a undirected graph from <i> adjacency_list </i> of <b> BOOST </b>, which the 
 * edges are a <i> std::vector </i> of contact points.
 *
 ********************************************************************************************************************************************
 * \section example Un exemple expliqué (Roland)
 **********************************************
 *
 * Nous ici détailler le fonctionnement d'un exemple, le fichier floe/collision/matlab/TEST_detector_from_mat.cpp.
 * Cet exemple charge une configuration de floes depuis un fichier Matlab et en détecte les points de collisions. 
 * Il construit ensuite les différents LCP associés au composantes connexes des contacts actifs, et en tente la résolution par la méthode de Lemke.
 *
 * Commençons par déclarer le type principal sur lequel on va baser tout le code, l'ensemble des réels :
 * \code
 * using real = double;
 * \endcode
 *
 * De là, on va déduire les classes que l'on va utiliser, tout d'abord celle des floes statiques :
 * \code
 * using TStaticFloe = floe::floes::StaticFloe<real>;
 * \endcode
 * puis celle des floes cinématiques, qui dépend des floes statiques :
 * \code
 * using TKinematicFloe = floe::floes::KinematicFloe< TStaticFloe >;
 * \endcode
 *
 * Enfin, il faut un détecteur de collision qui va travailler au niveau cinématique :
 * \code
 * using TDetector = floe::collision::matlab::MatlabDetector< TKinematicFloe >;
 * \endcode
 *
 * Une fois cela fait, on peut commencer le programme en récupérant les paramètres en ligne de commande :
 * \code
 *  if ( argc < 2 )
 *  {
 *      cout << "Usage: " << argv[0] << " <matlab_file_name>" << endl;
 *      return 1;
 *  }
 * \endcode
 *
 * La première étape va alors consister à charger le fichier Matlab fourni en paramètre et à en extraire la liste des floes.
 * On va tout d'abord charger la variable list_so dans une structure, floe::io::matlab::MatlabListSolid, qui reproduit fidèlement la structure de la variable Matlab :
 * \code
 * floe::io::matlab::MatlabListSolid<double> list_so;
 * read_list_so_from_file( argv[1], list_so );
 * \endcode
 * La structure floe::io::matlab::MatlabListSolid est ici templatée par double au lieu de real (qui peut être différent d'un double) pour refléter la représentation utilisée par Matlab. La conversion vers le type real sera effectué lors de l'étape suivante.
 *
 * La variable list_so contient maintenant l'équivalent de la variable Matlab de même nom. On peut maintenant convertir cette structure en liste de floes cinématiques :
 * \code
 * auto floe_list = list_so_to_floes<TKinematicFloe>( list_so );
 * \endcode
 * La variable floe_list est en fait de type <a href="http://en.cppreference.com/w/cpp/container/vector">std::vector<TKinematicFloe*></a>, c'est à dire une liste de pointeur vers des floes cinématiques. Il faudra donc penser à libérer la mémoire associée quand cette liste ne sera plus utile (ou utiliser des <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">Smart Pointer</a>). (surtout que le mot-clé <a href="http://en.cppreference.com/w/cpp/language/auto">auto</a> ne permet pas de s'en rendre compte ...)
 *
 * On va ensuite indiqué au détecteur de collision quels floes il doit surveiller, en l'occurence tous les floes :
 * \code
 * TDetector detector;
 * for ( auto const& floe_ptr : floe_list )
 *      detector.push_back( floe_ptr );
 * \endcode
 * On utilise ici la syntaxe <a href="http://en.cppreference.com/w/cpp/language/range-for">de boucle for pour les listes</a> de la norme C++11.
 * Le détecteur va ici créer une structure d'optimisation pour chacun des floes.
 *
 * On demande maintenant au détecteur de mettre à jour ces structures (si les floes se sont déplacés entre temps), de calculer les distances entre les floes et d'enregistrer les éventuelles collisions :
 * \code
 * detector.update();
 * \endcode
 *
 * Les collisions sont enregistrées dans un <a href="http://www.boost.org/doc/libs/1_57_0/libs/graph/doc/index.html">graphe</a> de type floe::collision::ContactGraph dont :
 * - chaque noeud représente un floe et possède un pointeur vers ce dernier;
 * - chaque arête représente une collision entre deux floes et est associée à un vecteur de points de contact de type floe::collision::ContactPoint.
 *
 * Ce graphe est ainsi indépendant du détecteur de collision et contient l'ensemble des informations nécessaires à la résolution de ces contacts.
 *
 * Plusieurs fonctions permettent de manipuler les graphes de contacts (voir le fichier floe/collision/contact_graph.hpp), comme par exemple récupérer le nombre de points de contacts :
 * \code
 * const std::size_t num = num_contacts( detector.contact_graph() );
 * \endcode
 *
 * Mais le principal intérêt est de pouvoir utiliser l'ensemble des outils disponibles pour les graphes, comme :
 * - l'extraction des <a href="http://www.boost.org/doc/libs/1_57_0/libs/graph/doc/connected_components.html">composantes connexes</a>, pour obtenir par exemple les groupes de floes en contact;
 * - le <a href="http://www.boost.org/doc/libs/1_57_0/libs/graph/doc/filtered_graph.html">filtrage d'un graphe</a> selon des prédicats sur les noeuds et/ou les arêtes, pour obtenir le graphe des collisions n'impliquant que des contacts actifs;
 * - l'extraction de <a href="http://www.boost.org/doc/libs/1_57_0/libs/graph/doc/subgraph.html">sous-graphe</a> pour, par exemple, manipuler les composantes connexes comme des graphes.
 *
 * On va donc commencer par l'extraction des groupes de floes en contact, représentant les composantes connexes du graphe :
 * \code
 * auto const subgraphs = collision_subgraphs( detector.contact_graph() );
 * \endcode
 * La variable subgraphs est maintenant une liste de sous-graphes, chacun représentant une composante connexe.
 *
 * Pour chacun de ces graphes, on va extraire les groupes de floes impliquant des contacts actifs (vitesse relative strictement négative) :
 * \code
 *  for ( auto const& connected_graph : subgraphs )
 *  {
 *      auto const& active_graph_list = active_subgraphs( connected_graph );
 * \endcode
 *
 * Une fois un graphe de contact extrait (quelque soit sa propriété), il faut résoudre les collisions associées en posant un <a href="http://en.wikipedia.org/wiki/Linear_complementarity_problem">problème linéaire complémentaire</a>. Pour cela, la classe floe::lcp::builder::GraphLCP permet de construire un floe::lcp::LCP à partir d'un graphe de contacts :
 * \code
 *      for ( auto const& active_graph : active_graph_list )
 *      {
 *          floe::lcp::builder::GraphLCP<real, decltype(graph)> graph_lcp( active_graph );
 * \endcode
 * Cette fabrique à LCP doit être templatée par le type fondamental (real) et le type de graphe de contacts que l'on récupère grâce au mot-clé <a href="http://en.cppreference.com/w/cpp/language/decltype">decltype</a>.
 * Une référence vers le graphe est stockée dans la classe afin d'imaginer pouvoir construire rapidement le LCP associé à un sous-graphe de contacts.
 *
 * Le LCP est ensuite récupéré via la commande :
 * \code
 * auto lcp = graph_lcp.getLCP();
 * \endcode
 *
 * Ce LCP pourra être résolu par un des solveurs disponibles, par exemple la <a href="http://web.stanford.edu/class/msande316/slides/050204.pdf">méthode de Lemke</a> avec tri lexicographique :
 * \code
 * error_status = floe::lcp::solver::lexicolemke_MR(tolerance, lcp, itermax);
 * \endcode
 * La solution du LCP est alors disponible dans le membre floe::lcp::LCP::z de la classe floe::lcp::LCP.
 *
 * On peut calculer l'erreur de la solution avec le code :
 * \code
 * const T error = lcp.LCP_error();
 * \endcode
 *
 * Il ne faut pas oublier, à la fin, de libérer la mémoire allouée pour les floes :
 * \code
 *          }
 *      }
 *
 *      // Freeing memory
 *      for ( auto& floe_ptr : floe_list )
 *          delete floe_ptr;
 *
 *      return 0;
 *  }
 *  \endcode
 */