/*!
 *
 * \mainpage Code C++ de simulation de floes
 *
 * \tableofcontents
 *
 * \section dev_todo À faire dans le code.
 *
 * - Tout traduire en Anglais !!!
 * - Générer une page de d'aide à l'installation et au lancement du code
 * - Générateur de configurations initiales de floes
 * - Compléter la documentation
 * - Créer des tests références pour vérifier que tout fonctionne bien
 * - Corriger bugs pour passer sur version ulterieure de <b> BOOST </b>
 *
 *
 * \subsection dev_optim Optimisation
 * 
 * \subsubsection dev_solver Solveur LCP
 * - voir la méthode de réduction de dimension de Lloyd 2005 (O(n^3) -> O(n))
 * - rendre plus propre la résolution des LCP par le développements des outils de base nécessaires : recherche de la variable bloquante, pivot, etc ...
 * - ensuite, permettre de modifier le comportement de ces outils, pour par exemple utiliser l'algo d'expansion du LCP de Lloyd 2005.
 * - voir Acary 2011 : A formulation of the linear discrete Coulomb friction problem via convex optimization. The novelty of their approach is to capture and treat directly the friction model as a parametric quadratic optimization problem with second-order cone constraints coupled with a fixed point equation.
 *
 * \subsubsection dev_multithread Parallélisation
 * - on peut facilement paralléliser la détection de contact,
 * - de même pour la résolution des contacts : à une étape donnée (groupes de contacts actifs), tous les LCPs peuvent se résoudre indépendamment les uns des autres ;
 * - à plus grande échelle, il faudrait pouvoir gérer l'ensemble des floes par groupes. On peut déjà avoir un détecteur de collision indépendant par groupe, il faut alors un autre détecteur sur les groupes eux-mêmes. Il faut également pouvoir détecter les "influences" entre groupes.
 * - Voir Drumwright 2010 (chapitre précédent), pour une optimisation sur GPU.
 * - Voir Mazhar 2015 pour une gestion des contacts avec méthodes facilement parallèlisable (accelerated projected gradient descent (APGD) method relies on an approach by Nesterov in which a quadratic optimization problem with conic constraints is solved at each simulation time step to recover the normal and friction forces present in the system).
 *
 * \section Installation
 *
 * \subsection Prerequisite
 * If you clone the GIT repository, you need at least the following to build the executable:
 * - Boost (version 1.57, Important, some routines need this version to compile).
 * 		+ Use for geometry, graphs, linear algebra, etc.
 * - Matio (version no matter) 
 *		+ Use for importing/exporting Matlab format files.
 * - Eigen (version no matter)
 * 		+ Use for linear algebra for linear complementarity problem.
 * - CGAL (version no matter)
 * 		+ Use for construction of mesh during the generation of floe assemblies.
 * - HDF5 (version no matter, addind <a href="https://support.hdfgroup.org/products/java/release/download.html">HDFView </a> for visualing files .h5)
 * 		+ Use for outputs.
 * - ffmpeg (version no matter)
 *		+ Use for generation of videos.
 * - python (version 2.7) (addind h5py, numpy and matplotlib)
 * 		+ Use for visualisation and generation of videos from outputs.
 * - doxygen (version no matter)
 * 		+ Use for generating documentation.
 * - graphviz (version no matter)
 * 		+ Use for generating graphics during the documentation generation.
 *
 * Every library could be installed with home brew. However you should be careful about: 
 * - when one install boost_1_57 with brew, one should check the folders <i> /usr/local/lib/ </i> and <i> /usr/local/include/ </i> contain the boost libraries and include (or link). It is required to compile.
 * Otherwise, one should install boost_1_57 without brew (see: <a href="http://www.boost.org/doc/libs/1_65_1/more/getting_started/unix-variants.html">the boost user manual for unix-variants</a>). 
 * - when one install CGAL with brew, CGAL needing boost, it may be that brew install the lastest version of boost. In this case, please install CGAL without brew 
 * (see: <a href="https://doc.cgal.org/latest/Manual/installation.html">CGAL user manual </a>).
 *
 *
 * \subsection get_start Getting Started
 *
 * Once libraries have been installed, please check with the command:
 *
 * \code
 * $ cd /path/to/FloeCpp
 * $ ./waf configure
 * \endcode
 *
 * You should obtain something like this:
 * \image html waf_config.png width=800
 *
 * \subsection Compilation
 *
 * \code
 * $ ./waf --target FLOE
 * \endcode
 *
 * or 
 * \code
 * $ ./waf --target FLOE_PBC
 * \endcode
 *
 * or, all <i> .cpp </i> files contained in <i> product </i> folder. The executable are in the <i> build </i> folder.
 *
 * \subsection \first_run First Running
 *
 * Run:
 * \code
 * $ ./build/FLOE -h
 * \endcode
 * allow to know which options are availables
 *
 * Before running any simulations, please build floe configurations:
 * \code
 * $ ./build/FLOE -i generator -n 1000 -c 0.6 -t 0
 * \endcode
 * generation of 1000 floes with a concentration equal to 60 percent. At the end, the simulation, which the last is <i> t=0 </i>, starts.
 * 
 * First example:
 * \code
 * $ ./build/FLOE -i io/inputs/in_700f_60p_#1.h5 -t 10000
 * \endcode
 * running the floe configuration called <i> in_700f_60p_#1.h5 </i> (for 700 floes with a ice concentration equal to 60 percent) during 10000 secondes.
 * 
 * The output files (in .h5) are in the <i> io/outputs </i> folder. To generate a video, please type:
 * \code
 * $ python3 plot anim -f io/outputs/outputs.h5
 * \endcode
 * replacing <i> outputs.h5 </i> by the name of the outputs files in the <i> io/outputs </i> folder.
 * Be careful, <i> plot </i> is a folder containing <b> python </b> files in order to create a video in <i> videos </i> folder. One have to build the <i> io/videos </i> folder before.
 * 
 * Informations on the floe assemblies:
 * \code
 * $ ./build/FLOE_INPUT_INFO io/inputs/in_2000f_60p_jKtIx.h5
 * \endcode 
 *
 * \section Debug
 * Two tools:
 * - with <b> X-Code </b>.
 * - with <b> valgrind </b>.
 * 
 * \subsection with valgrind:
 *
 * First, please compilling without <i> --debug </i>:
 * \code 
 * $ ./waf --target FLOE
 * endcode
 * Then, launching the simulation with the command: 
 * \code 
 * $ valgrind --leak-check=full ./build/FLOE -i io/inputs/in_700f_60p_#1.h5 -t 10000
 * endcode
 *
 * \subsection with X-Code (or just with option --debug):
 * 
 * First, please compilling with <i> --debug </i>:
 * \code 
 * $ ./waf --target FLOE --debug
 * endcode
 * So, the different <i> assert() </i> function will be activated.
 *
 * \section example Un exemple expliqué (Roland)
 *
 * Nous ici détailler le fonctionnement d'un exemple, le fichier floe/collision/matlab/TEST_detector_from_mat.cpp.
 * Cet exemple charge une configuration de floes depuis un fichier Matlab et en détecte les points de collisions. 
 * Il construit ensuite les différents LCP associés au composantes connexes des contacts actifs, et en tente la résolution par la méthode de Lemke.
 *
 * Commençons par déclarer le type principal sur lequel on va baser tout le code, l'ensemble des réels :
 * \code
 * using real = double;
 * \endcode
 *
 * De là, on va déduire les classes que l'on va utiliser, tout d'abord celle des floes statiques :
 * \code
 * using TStaticFloe = floe::floes::StaticFloe<real>;
 * \endcode
 * puis celle des floes cinématiques, qui dépend des floes statiques :
 * \code
 * using TKinematicFloe = floe::floes::KinematicFloe< TStaticFloe >;
 * \endcode
 *
 * Enfin, il faut un détecteur de collision qui va travailler au niveau cinématique :
 * \code
 * using TDetector = floe::collision::matlab::MatlabDetector< TKinematicFloe >;
 * \endcode
 *
 * Une fois cela fait, on peut commencer le programme en récupérant les paramètres en ligne de commande :
 * \code
 *  if ( argc < 2 )
 *  {
 *      cout << "Usage: " << argv[0] << " <matlab_file_name>" << endl;
 *      return 1;
 *  }
 * \endcode
 *
 * La première étape va alors consister à charger le fichier Matlab fourni en paramètre et à en extraire la liste des floes.
 * On va tout d'abord charger la variable list_so dans une structure, floe::io::matlab::MatlabListSolid, qui reproduit fidèlement la structure de la variable Matlab :
 * \code
 * floe::io::matlab::MatlabListSolid<double> list_so;
 * read_list_so_from_file( argv[1], list_so );
 * \endcode
 * La structure floe::io::matlab::MatlabListSolid est ici templatée par double au lieu de real (qui peut être différent d'un double) pour refléter la représentation utilisée par Matlab. La conversion vers le type real sera effectué lors de l'étape suivante.
 *
 * La variable list_so contient maintenant l'équivalent de la variable Matlab de même nom. On peut maintenant convertir cette structure en liste de floes cinématiques :
 * \code
 * auto floe_list = list_so_to_floes<TKinematicFloe>( list_so );
 * \endcode
 * La variable floe_list est en fait de type <a href="http://en.cppreference.com/w/cpp/container/vector">std::vector<TKinematicFloe*></a>, c'est à dire une liste de pointeur vers des floes cinématiques. Il faudra donc penser à libérer la mémoire associée quand cette liste ne sera plus utile (ou utiliser des <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">Smart Pointer</a>). (surtout que le mot-clé <a href="http://en.cppreference.com/w/cpp/language/auto">auto</a> ne permet pas de s'en rendre compte ...)
 *
 * On va ensuite indiqué au détecteur de collision quels floes il doit surveiller, en l'occurence tous les floes :
 * \code
 * TDetector detector;
 * for ( auto const& floe_ptr : floe_list )
 *      detector.push_back( floe_ptr );
 * \endcode
 * On utilise ici la syntaxe <a href="http://en.cppreference.com/w/cpp/language/range-for">de boucle for pour les listes</a> de la norme C++11.
 * Le détecteur va ici créer une structure d'optimisation pour chacun des floes.
 *
 * On demande maintenant au détecteur de mettre à jour ces structures (si les floes se sont déplacés entre temps), de calculer les distances entre les floes et d'enregistrer les éventuelles collisions :
 * \code
 * detector.update();
 * \endcode
 *
 * Les collisions sont enregistrées dans un <a href="http://www.boost.org/doc/libs/1_57_0/libs/graph/doc/index.html">graphe</a> de type floe::collision::ContactGraph dont :
 * - chaque noeud représente un floe et possède un pointeur vers ce dernier;
 * - chaque arête représente une collision entre deux floes et est associée à un vecteur de points de contact de type floe::collision::ContactPoint.
 *
 * Ce graphe est ainsi indépendant du détecteur de collision et contient l'ensemble des informations nécessaires à la résolution de ces contacts.
 *
 * Plusieurs fonctions permettent de manipuler les graphes de contacts (voir le fichier floe/collision/contact_graph.hpp), comme par exemple récupérer le nombre de points de contacts :
 * \code
 * const std::size_t num = num_contacts( detector.contact_graph() );
 * \endcode
 *
 * Mais le principal intérêt est de pouvoir utiliser l'ensemble des outils disponibles pour les graphes, comme :
 * - l'extraction des <a href="http://www.boost.org/doc/libs/1_57_0/libs/graph/doc/connected_components.html">composantes connexes</a>, pour obtenir par exemple les groupes de floes en contact;
 * - le <a href="http://www.boost.org/doc/libs/1_57_0/libs/graph/doc/filtered_graph.html">filtrage d'un graphe</a> selon des prédicats sur les noeuds et/ou les arêtes, pour obtenir le graphe des collisions n'impliquant que des contacts actifs;
 * - l'extraction de <a href="http://www.boost.org/doc/libs/1_57_0/libs/graph/doc/subgraph.html">sous-graphe</a> pour, par exemple, manipuler les composantes connexes comme des graphes.
 *
 * On va donc commencer par l'extraction des groupes de floes en contact, représentant les composantes connexes du graphe :
 * \code
 * auto const subgraphs = collision_subgraphs( detector.contact_graph() );
 * \endcode
 * La variable subgraphs est maintenant une liste de sous-graphes, chacun représentant une composante connexe.
 *
 * Pour chacun de ces graphes, on va extraire les groupes de floes impliquant des contacts actifs (vitesse relative strictement négative) :
 * \code
 *  for ( auto const& connected_graph : subgraphs )
 *  {
 *      auto const& active_graph_list = active_subgraphs( connected_graph );
 * \endcode
 *
 * Une fois un graphe de contact extrait (quelque soit sa propriété), il faut résoudre les collisions associées en posant un <a href="http://en.wikipedia.org/wiki/Linear_complementarity_problem">problème linéaire complémentaire</a>. Pour cela, la classe floe::lcp::builder::GraphLCP permet de construire un floe::lcp::LCP à partir d'un graphe de contacts :
 * \code
 *      for ( auto const& active_graph : active_graph_list )
 *      {
 *          floe::lcp::builder::GraphLCP<real, decltype(graph)> graph_lcp( active_graph );
 * \endcode
 * Cette fabrique à LCP doit être templatée par le type fondamental (real) et le type de graphe de contacts que l'on récupère grâce au mot-clé <a href="http://en.cppreference.com/w/cpp/language/decltype">decltype</a>.
 * Une référence vers le graphe est stockée dans la classe afin d'imaginer pouvoir construire rapidement le LCP associé à un sous-graphe de contacts.
 *
 * Le LCP est ensuite récupéré via la commande :
 * \code
 * auto lcp = graph_lcp.getLCP();
 * \endcode
 *
 * Ce LCP pourra être résolu par un des solveurs disponibles, par exemple la <a href="http://web.stanford.edu/class/msande316/slides/050204.pdf">méthode de Lemke</a> avec tri lexicographique :
 * \code
 * floe::lcp::solver::lexicolemke(lcp);
 * \endcode
 * La solution du LCP est alors disponible dans le membre floe::lcp::LCP::z de la classe floe::lcp::LCP.
 *
 * On peut calculer l'erreur de la solution avec le code :
 * \code
 * const real error = floe::lcp::LCP_error(lcp);
 * \endcode
 *
 * Il ne faut pas oublier, à la fin, de libérer la mémoire allouée pour les floes :
 * \code
 *          }
 *      }
 *
 *      // Freeing memory
 *      for ( auto& floe_ptr : floe_list )
 *          delete floe_ptr;
 *
 *      return 0;
 *  }
 *  \endcode
 */